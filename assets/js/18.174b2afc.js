(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{204:function(t,s,a){t.exports=a.p+"assets/img/aqs_001.e6112c6c.png"},318:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"juc锁-锁核心类aqs详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#juc锁-锁核心类aqs详解"}},[t._v("#")]),t._v(" JUC锁: 锁核心类AQS详解")]),t._v(" "),n("blockquote",[n("p",[t._v("AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。")])]),t._v(" "),n("div",{staticClass:"custom-block warning"},[n("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("什么是AQS? 为什么它是核心?")])]),t._v(" "),n("li",[n("p",[t._v("AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等")])]),t._v(" "),n("li",[n("p",[t._v("AQS有哪些核心的方法?")])]),t._v(" "),n("li",[n("p",[t._v("AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式："),n("strong",[t._v("独占")]),t._v("(只有一个线程能访问执行，又根据是否"),n("strong",[t._v("按队列")]),t._v("的顺序分为"),n("strong",[t._v("公平锁")]),t._v("和"),n("strong",[t._v("非公平锁")]),t._v("，\n如"),n("strong",[t._v("ReentrantLock")]),t._v(") 和"),n("strong",[t._v("共享")]),t._v("(多个线程可同时访问执行，如"),n("strong",[t._v("Semaphore")]),t._v("、"),n("strong",[t._v("CountDownLatch")]),t._v("、 "),n("strong",[t._v("CyclicBarrier")]),t._v(" )。\nReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。")])]),t._v(" "),n("li",[n("p",[t._v("AQS底层使用了什么样的设计模式? "),n("strong",[t._v("模板")])])]),t._v(" "),n("li",[n("p",[t._v("AQS的应用示例?")])])])]),t._v(" "),n("h2",{attrs:{id:"abstractqueuedsynchronizer简介-就是个同步器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstractqueuedsynchronizer简介-就是个同步器"}},[t._v("#")]),t._v(" AbstractQueuedSynchronizer简介(就是个同步器)")]),t._v(" "),n("p",[t._v("类如其名，抽象的队列式的同步器")]),t._v(" "),n("p",[t._v("AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的"),n("strong",[t._v("ReentrantLock")]),t._v("，"),n("strong",[t._v("Semaphore")]),t._v("，\n其他的诸如"),n("strong",[t._v("ReentrantReadWriteLock")]),t._v("，"),n("strong",[t._v("SynchronousQueue")]),t._v("，"),n("strong",[t._v("FutureTask")]),t._v("等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。")]),t._v(" "),n("h2",{attrs:{id:"aqs-核心思想"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aqs-核心思想"}},[t._v("#")]),t._v(" AQS 核心思想")]),t._v(" "),n("p",[t._v("AQS核心思想：")]),t._v(" "),n("p",[t._v("如果被请求的"),n("strong",[t._v("共享资源空闲")]),t._v("，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。")]),t._v(" "),n("p",[t._v("如果被请求的"),n("strong",[t._v("共享资源被占用")]),t._v("，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用"),n("strong",[t._v("CLH队列锁")]),t._v("实现的，即将"),n("strong",[t._v("暂时获取不到锁的线程加入到队列")]),t._v("中。")]),t._v(" "),n("blockquote",[n("p",[t._v("CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。")])]),t._v(" "),n("p",[n("img",{attrs:{src:a(204),alt:"资源分配过程",title:"资源分配过程"}})]),t._v(" "),n("blockquote",[n("p",[t._v("AQS是将每条请求共享资源的线程封装成一个CLH线程等待锁队列(多线程争用资源被阻塞时会进入此队列)的一个结点(Node)来实现锁的分配。")])]),t._v(" "),n("p",[t._v("AQS使用一个int成员变量来表示同步状态("),n("strong",[t._v("代表共享资源")]),t._v(")，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//共享变量，使用volatile修饰保证线程可见性")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br")])]),n("p",[t._v("state 的访问方式：状态信息通过protected类型的getState，setState，compareAndSetState进行操作")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//返回同步状态的当前值")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" state"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置同步状态的值")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" newState"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n        state "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" newState"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetState")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" expect"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" update"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSwapInt")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" stateOffset"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" expect"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" update"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br")])]),n("h2",{attrs:{id:"aqs-对资源的共享方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aqs-对资源的共享方式"}},[t._v("#")]),t._v(" AQS 对资源的共享方式")]),t._v(" "),n("p",[t._v("AQS定义两种资源共享方式:")]),t._v(" "),n("ul",[n("li",[t._v("Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：")])]),t._v(" "),n("p",[n("strong",[t._v("公平锁")]),t._v("：按照线程在队列中的排队顺序，先到者先拿到锁")]),t._v(" "),n("p",[n("strong",[t._v("非公平锁")]),t._v("：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的")]),t._v(" "),n("ul",[n("li",[t._v("Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。")])]),t._v(" "),n("p",[t._v("ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是"),n("strong",[t._v("读写锁")]),t._v("允许多个线程同时对某一资源进行读。")]),t._v(" "),n("p",[t._v("不同的自定义同步器争用共享资源的方式也不同。"),n("strong",[t._v("自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可")]),t._v("，\n至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。")]),t._v(" "),n("h2",{attrs:{id:"aqs底层使用了模板方法模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aqs底层使用了模板方法模式"}},[t._v("#")]),t._v(" AQS底层使用了模板方法模式")]),t._v(" "),n("blockquote",[n("p",[t._v("同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样(模板方法模式很经典的一个应用)：")])]),t._v(" "),n("p",[n("strong",[t._v("自定义同步器")])]),t._v(" "),n("p",[t._v("使用者继承AbstractQueuedSynchronizer并重写指定的方法。(这些重写方法很简单，无非是对于共享资源state的获取和释放)\n将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。")]),t._v(" "),n("p",[t._v("这和我们以往通过实现接口的方式有很大区别，模板方法模式请参看：设计模式行为型 - 模板方法(Template Method)详解")]),t._v(" "),n("p",[t._v("AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token function"}},[t._v("isHeldExclusively")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//该线程是否正在独占资源。只有用到condition才需要去实现它。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//独占方式。尝试获取资源，成功则返回true，失败则返回false。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryRelease")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//独占方式。尝试释放资源，成功则返回true，失败则返回false。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquireShared")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryReleaseShared")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//共享方式。尝试释放资源，成功则返回true，失败则返回false。")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br")])]),n("p",[t._v("默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。\nAQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。")]),t._v(" "),n("p",[t._v("以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，\n直到A线程unlock()到state=0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。\n但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。")]),t._v(" "),n("p",[t._v("再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，\nstate会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。")]),t._v(" "),n("p",[t._v("一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。")]),t._v(" "),n("p",[t._v("但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。")])])}),[],!1,null,null,null);s.default=e.exports}}]);