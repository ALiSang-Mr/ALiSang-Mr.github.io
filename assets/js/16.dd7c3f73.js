(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{222:function(v,t,a){v.exports=a.p+"assets/img/memory_001.4f641864.jpg"},223:function(v,t,a){v.exports=a.p+"assets/img/memory_002.46be7aaa.jpg"},303:function(v,t,a){"use strict";a.r(t);var _=a(0),r=Object(_.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"运行时数据区-内存结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区-内存结构"}},[v._v("#")]),v._v(" 运行时数据区(内存结构)")]),v._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#堆"}},[v._v("堆")])]),_("li",[_("a",{attrs:{href:"#java虚拟机栈-线程栈"}},[v._v("Java虚拟机栈(线程栈)")])]),_("li",[_("a",{attrs:{href:"#方法区-元空间"}},[v._v("方法区(元空间)")])]),_("li",[_("a",{attrs:{href:"#程序计数器"}},[v._v("程序计数器")])]),_("li",[_("a",{attrs:{href:"#本地方法栈"}},[v._v("本地方法栈")])])])]),_("p"),v._v(" "),_("h2",{attrs:{id:"堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),_("p",[v._v('所有对象都在这里分配内存，是垃圾收集的主要区域("GC 堆")。')]),v._v(" "),_("p",[v._v("现代的垃圾收集器基本都是采用分代收集算法，针对不同类型的对象采取不同的垃圾回收算法，可以将堆分成两块:")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("新生代(Young Generation)")])]),v._v(" "),_("li",[_("p",[v._v("老年代(Old Generation)")])])]),v._v(" "),_("p",[v._v("新生代可以继续划分成以下三个空间:")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Eden(伊甸园)")])]),v._v(" "),_("li",[_("p",[v._v("From Survivor(幸存者)")])])]),v._v(" "),_("p",[v._v("-To Survivor")]),v._v(" "),_("p",[v._v("堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。")]),v._v(" "),_("p",[v._v("可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。")]),v._v(" "),_("p",[v._v("成员变量存储在堆中的对象里面，由垃圾回收器负责回收。")]),v._v(" "),_("h2",{attrs:{id:"java虚拟机栈-线程栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈-线程栈"}},[v._v("#")]),v._v(" Java虚拟机栈(线程栈)")]),v._v(" "),_("p",[v._v("方法的调用符合数据结构中的栈的特点FILO(先进后出)")]),v._v(" "),_("p",[v._v("栈的内部结构由一块一块的栈帧组成")]),v._v(" "),_("p",[_("img",{attrs:{src:a(222),alt:"Java虚拟机栈",title:"Java虚拟机栈"}})]),v._v(" "),_("p",[v._v("一个方法对应一块栈帧内存区域，用来放方法当中自己的局部变量等信息")]),v._v(" "),_("p",[v._v("每个 Java 方法在执行的同时会创建一个"),_("strong",[v._v("栈帧")]),v._v("用于存储局部变量表、操作数栈、动态链接、方法出口等信息，\n从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。")]),v._v(" "),_("p",[v._v("局部变量表:存放方法当中的局部变量  比如int a=1  int b=2   "),_("strong",[v._v("存放分配到堆当中的对象的引用(指针)[内存地址]")])]),v._v(" "),_("p",[v._v("操作数栈:放操作数的区域 进行操作数计算")]),v._v(" "),_("p",[v._v("动态链接")]),v._v(" "),_("p",[v._v("方法出口:记录方法被调用的位置，当方法执行完之后再回到被调用的地方")]),v._v(" "),_("h2",{attrs:{id:"方法区-元空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法区-元空间"}},[v._v("#")]),v._v(" 方法区(元空间)")]),v._v(" "),_("p",[v._v("用于存放被类加载子系统加载的"),_("strong",[v._v("类信息")]),v._v("、"),_("strong",[v._v("常量")]),v._v("、"),_("strong",[v._v("静态变量")]),v._v("、即时编译器编译后的代码等数据。")]),v._v(" "),_("p",[v._v("运行时常量池是方法区的一部分。")]),v._v(" "),_("p",[v._v("Class 文件中的常量池(编译器生成的各种字面量和符号引用)会在类加载后被放入这个区域。")]),v._v(" "),_("p",[v._v("除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。")]),v._v(" "),_("p",[_("img",{attrs:{src:a(223),alt:"Java虚拟机栈",title:"内存关系"}})]),v._v(" "),_("h2",{attrs:{id:"程序计数器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[v._v("#")]),v._v(" 程序计数器")]),v._v(" "),_("p",[v._v("也是一片内存区域，存储的是记录当前线程指令执行的行号")]),v._v(" "),_("p",[v._v("由字节码执行引擎来修改操作")]),v._v(" "),_("p",[v._v("为什么会有程序计数器？ 当多线程切换执行时，切换回当前线程，则需要调出之前线程执行的位置。")]),v._v(" "),_("h2",{attrs:{id:"本地方法栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),_("p",[v._v("本地方法一般是用其它语言(C、C++ 或汇编语言等)编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。")]),v._v(" "),_("p",[v._v("本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。")])])}),[],!1,null,null,null);t.default=r.exports}}]);